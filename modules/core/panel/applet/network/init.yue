import "awful"
import "gears"
import "wibox"
import "beautiful"

import scale, lookup_icon from "modules.lib.theme"

import "modules.core.panel.common"
import basic_container from common

import Gio from "lgi"

-- https://people.freedesktop.org/~lkundrak/nm-docs/nm-dbus-types.html#NMDeviceType
export nm_device_type = {
	unknown: 0 -- unknown device
	ethernet: 1 -- a wired ethernet device
	wifi: 2 -- an 802.11 WiFi device
	-- 3 and 4 are unused
	bluetooth: 5 -- a Bluetooth device supporting PAN or DUN access protocols
	olpc_mesh: 6 -- an OLPC XO mesh networking device
	wimax: 7 -- an 802.16e Mobile WiMAX broadband device
	modem: 8 -- a modem supporting analog telephone, CDMA/EVDO, GSM/UMTS, or LTE network access protocols
	infiniband: 9 -- an IP-over-InfiniBand device
	bond: 10 -- a bond master interface
	vlan: 11 -- an 802.1Q VLAN interface
	adsl: 12 -- ADSL modem
	bridge: 13 -- a bridge master interface
	generic: 14 -- generic support for unrecognized device types
	team: 15 -- a team master interface
	tun: 16 -- a TUN or TAP interface
	ip_tunnel: 17 -- a IP tunnel interface
	macvlan: 18 -- a MACVLAN interface
	vxlan: 19 -- a VXLAN interface
	veth: 20 -- a VETH interface
}

-- https://people.freedesktop.org/~lkundrak/nm-docs/nm-dbus-types.html#NMState
export nm_state = {
	unknown: 0
	asleep: 10
	disconnected: 20
	disconnecting: 30
	connecting: 40
	connected_local: 50
	connected_site: 60
	connected_global: 70
}

export loading_spinner_widget = {
	get_arc_rotation: () =>
		@_private.arc_rotation

	set_arc_rotation: (value) =>
		@_private.arc_rotation = value
		@emit_signal("property::arc_rotation", value)
		@emit_signal("widget::redraw_needed")

	draw: (_, cr, w, h) =>
		notify("cr = #{cr}, w = #{w}, h = #{h}")

	<call>: (cls, kwargs={}) ->
		const self = wibox.widget.base.make_widget(nil, nil, { enable_properties: true })
			|> gears.table.crush(cls)
			|> gears.table.crush(kwargs)

		@_private ??= {}

		@arc_rotation = 0

		gears.timer {
			autostart: true
			timeout:   1/5
			callback:  () ->
				@arc_rotation = (@arc_rotation + 1) % 360
		}

		@
}

const connection_status_visual_role_widgets = {
	loading: wibox.widget {
		widget: loading_spinner_widget
	}
	offline: wibox.widget {
		image:  lookup_icon("network-offline")
		widget: wibox.widget.imagebox
	}
	online: wibox.widget {
		image:  lookup_icon("network-transmit-receive")
		widget: wibox.widget.imagebox
	}
}

export widget_template = {
	id:     "connection_status_visual_role"
	widget: basic_container
}

export to_snake_case = (str) ->
	str
		::gsub("^[A-Z]", string.lower)
		::gsub("([a-z])([A-Z])", (a, b) -> "#{a}_#{b::lower()}")

local dbus_proxy
do
	local err = nil
	dbus_proxy, err = Gio.DBusProxy.new_for_bus_sync(
		Gio.BusType.SYSTEM
		{ Gio.DBusProxyFlags.NONE }
		nil
		"org.freedesktop.NetworkManager"
		"/org/freedesktop/NetworkManager"
		"org.freedesktop.NetworkManager"
	)

	if err != nil
		error(err)

	dbus_proxy.on_g_properties_changed = (changed_properties, invalidated_properties) =>
		const { :value } = changed_properties

		awesome.emit_signal("network::wifi::properties_changed", changed_properties)

		for k, v in changed_properties::pairs()
			awesome.emit_signal("network::wifi::property_changed::#{k}", v.value)

export.<call> = (cls, kwargs={}) ->
	with kwargs
		assert(.screen)
		assert(.config)
		assert(.helpers)

	{ :screen, :config, :helpers } = kwargs

	const self = wibox.widget(cls.widget_template)

	awesome.connect_signal("network::wifi::property_changed::State", (value) ->
		const index = if value >= 50
			--	"online"
			--elseif value >= 30
			"loading"
		else
			"offline"

		for child in *@get_children_by_id("connection_status_visual_role")
			child.widget = connection_status_visual_role_widgets[index]
	)

	gears.timer.delayed_call () ->
		for property in *dbus_proxy::get_cached_property_names()
			awesome.emit_signal(
				"network::wifi::property_changed::#{property}"
				dbus_proxy::get_cached_property(property).value
			)

	@
