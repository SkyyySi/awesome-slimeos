--- To try out this module, you can put something like this in your `rc.yue`:
---
--- ```yuescript
--- import "native"
---
--- const box = wibox {
--- 	height:  scale(300)
--- 	width:   scale(300)
--- 	visible: true
--- 	ontop:   true
--- 	bg:      "#202020"
--- }
---
--- awful.placement.bottom_left(box, { honor_workarea: true, margins: scale(5) })
---
--- box.widget = {
--- 	{
--- 		{
--- 			image:  "#{gears.filesystem.get_configuration_dir()}/native/test2.png"
--- 			halign: "center"
--- 			valign: "center"
--- 			widget: wibox.widget.imagebox
--- 		}
--- 		dual_pass: true
--- 		radius: 5
--- 		widget: native.blur
--- 	}
--- 	{
--- 		id:     "text_role"
--- 		text:   "T"
--- 		font:   "Source Sans Pro, Bold 18"
--- 		halign: "center"
--- 		valign: "center"
--- 		widget: wibox.widget.textbox
--- 	}
--- 	layout: wibox.layout.stack
--- }
---
--- const text = "This is a test message!"
--- local count = 1
--- const textbox = box.widget::get_children_by_id("text_role")[1]
--- const timer = gears.timer {
--- 	timeout:   0.1
--- 	autostart: true
--- 	callback:  () ->
--- 		count += 1
--- 		textbox.text = text::sub(1, count)
--- }
--- ```

import "awful"
import "gears"
import "wibox"
import "beautiful"

import "native.native"

from "lgi" import Gdk, cairo

assert_param_type = (func_name, position, wanted_type, value) ->
	const value_type = type(value)

	assert((value_type == wanted_type), "Wrong type of parameter #%d passed to '%s' (expected %s, got %s)"::format(position, func_name, wanted_type, value_type))

export fill_context_with_surface = (cr, surface) ->
	const original_source = cr::get_target()

	cr::set_source_surface(surface, 0, 0)
	cr::paint()

	cr::set_source(original_source)

export gen_property = (object, property) ->
	assert_param_type("gen_property", 1, "table",  object)
	assert_param_type("gen_property", 2, "string", property)

	object["get_#{property}"] = () =>
		@_private[property]

	object["set_#{property}"] = (value) =>
		@_private[property] = value
		@emit_signal("property::#{property}", value)
		@_private.force_redraw = true
		@emit_signal("widget::redraw_needed")

export copy = (tb) ->
	const copy_of_tb = { k, v for k, v in pairs(tb) }

	copy_of_tb.<> = tb.<>

	copy_of_tb

export base = {
	get_widget: () =>
		@_private.widget

	set_widget: (widget) =>
		if @_private.child_redraw_listener == nil
			@_private.child_redraw_listener = () ->
				@_private.force_redraw = true
				@emit_signal("widget::redraw_needed")

		const child_redraw_listener = @_private.child_redraw_listener

		if @_private.widget?
			@_private.widget::disconnect_signal("widget::redraw_needed", child_redraw_listener)

		widget::connect_signal("widget::redraw_needed", child_redraw_listener)

		wibox.widget.base.set_widget_common(@, widget)

	get_children: () =>
		{ @_private.widget }

	set_children: (children) =>
		@set_widget(children[1])

	draw: (context, cr, width, height) =>
		const child = @get_widget()

		if child == nil
			return

		if (not self._private.force_redraw) and (@_private.cached_surface?)
			fill_context_with_surface(cr, @_private.cached_surface)
			return

		const surface = if @on_draw?
			@on_draw(cr, width, height, child)
		else
			wibox.widget.draw_to_image_surface(child, width, height)

		@_private.force_redraw = false
		@_private.cached_surface = surface

		fill_context_with_surface(cr, surface)

	<call>: (cls, kwargs={}) ->
		const self = wibox.widget.base.make_widget(nil, "surface_filter", { enable_properties: true })
			|> gears.table.crush(cls)

		@_private ??= {}

		if cls.parse_kwargs?
			cls.parse_kwargs(kwargs)

		for k, v in pairs(kwargs)
			@[k] = v

		@
}

export blur = with blur = copy(base)
	gen_property(blur, "radius")

	blur.on_draw = (cr, w, h, child) =>
		assert(@radius)

		const surface = wibox.widget.draw_to_image_surface(child, w, h)._native

		const surface_processed = cairo.Surface(if @dual_pass?
			const half = @radius / 2
			surface
				|> native.cairo_image_surface_apply_blur(math.ceil(half))
				|> native.cairo_image_surface_apply_blur(math.floor(half))
		else
			native.cairo_image_surface_apply_blur(surface, @radius)
		)

		fill_context_with_surface(cr, surface_processed)

	blur.parse_kwargs = (kwargs) ->
		with kwargs
			.radius ??= 10
			.opacity ??= 1.0
			.dual_pass ??= false
