import "awful"
import "gears"
import "wibox"
import "beautiful"

import "native.native"

from "lgi" import Gdk, cairo

assert_param_type = (func_name, position, wanted_type, value) ->
	const value_type = type(value)

	assert((value_type == wanted_type), "Wrong type of parameter #%d passed to '%s' (expected %s, got %s)"::format(position, func_name, wanted_type, value_type))

export fill_context_with_surface = (cr, surface) ->
	const original_source = cr::get_target()

	cr::set_source_surface(surface, 0, 0)
	cr::paint()

	cr::set_source(original_source)

export gen_property = (object, property) ->
	assert_param_type("gen_property", 1, "table",  object)
	assert_param_type("gen_property", 2, "string", property)

	object["get_#{property}"] = () =>
		@_private[property]

	object["set_#{property}"] = (value) =>
		@_private[property] = value
		@emit_signal("property::#{property}", value)
		@_private.force_redraw = true
		@emit_signal("widget::redraw_needed")

export copy = (tb) ->
	const copy_of_tb = { k, v for k, v in pairs(tb) }

	copy_of_tb.<> = tb.<>

	copy_of_tb

export base = {
	get_widget: () =>
		@_private.widget

	set_widget: (widget) =>
		if @_private.child_redraw_listener == nil
			@_private.child_redraw_listener = () ->
				@_private.force_redraw = true
				@emit_signal("widget::redraw_needed")

		const child_redraw_listener = @_private.child_redraw_listener

		if @_private.widget?
			@_private.widget::disconnect_signal("widget::redraw_needed", child_redraw_listener)

		widget::connect_signal("widget::redraw_needed", child_redraw_listener)

		wibox.widget.base.set_widget_common(@, widget)

	get_children: () =>
		{ @_private.widget }

	set_children: (children) =>
		@set_widget(children[1])

	draw: (context, cr, width, height) =>
		const child = @get_widget()

		if child == nil
			return

		if (not self._private.force_redraw) and (@_private.cached_surface?)
			fill_context_with_surface(cr, @_private.cached_surface)
			return

		const surface = if @on_draw?
			@on_draw(cr, width, height, child)
		else
			wibox.widget.draw_to_image_surface(child, width, height)

		@_private.force_redraw = false
		@_private.cached_surface = surface

		fill_context_with_surface(cr, surface)

	<call>: (cls, kwargs={}) ->
		const self = wibox.widget.base.make_widget(nil, "surface_filter", { enable_properties: true })
			|> gears.table.crush(cls)

		@_private ??= {}

		if cls.parse_kwargs?
			cls.parse_kwargs(kwargs)

		for k, v in pairs(kwargs)
			@[k] = v

		@
}

export blur = with blur = copy(base)
	gen_property(blur, "radius")

	blur.on_draw = (cr, w, h, child) =>
		assert(@radius)

		const surface = wibox.widget.draw_to_image_surface(child, w, h)._native

		const surface_processed = cairo.Surface(if @dual_pass?
			const half = @radius / 2
			surface
				|> native.cairo_image_surface_apply_blur(math.ceil(half))
				|> native.cairo_image_surface_apply_blur(math.floor(half))
		else
			native.cairo_image_surface_apply_blur(surface, @radius)
		)

		fill_context_with_surface(cr, surface_processed)

	blur.parse_kwargs = (kwargs) ->
		with kwargs
			.radius ??= 10
			.opacity ??= 1.0
			.dual_pass ??= false
